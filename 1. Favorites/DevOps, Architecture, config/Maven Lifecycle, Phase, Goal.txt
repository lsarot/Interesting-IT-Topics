MAVEN SCOPES, BUILD LIFECYCLE, PHASES, GOALS

--------------------------------------- DEPENDENCIES AND THEIR SCOPES
https://www.baeldung.com/maven-dependency-scopes

Simply put, there are two types of dependencies in Maven 'direct and transitive'.
'Direct' dependencies are the ones that are explicitly included in the project. 
'Transitive' dependencies, on the other hand, are dependencies required by our direct dependencies. Required transitive dependencies are automatically included in our project by Maven.

We can list all dependencies including transitive dependencies in the project using:
	mvn dependency:tree

Dependency scopes can help to limit transitivity of the dependencies and they modify classpath for different built tasks.
Maven has 6 default dependency scopes. And it is important to understand that each scope – except for import – does have an impact on transitive dependencies.

compile
provided
runtime
test
system
import


--------------------------------------- BUILD LIFECYCLES AND PHASES
https://www.baeldung.com/maven-goals-phases

Maven is based around the central concept of a Build Life Cycles. 
Inside each Build Life Cycles there are Build Phases, 
and inside each Build Phases there are Build Goals.

We can execute either a build phase or build goal. When executing a build phase we execute all build goals within that build phase. Build goals are assigned to one or more build phases. We can also execute a build goal directly.

Analogy: Plugin is a class and goals are methods within the class. 

There are three major built-in Build Life Cycles:

    default: the main life cycle as its responsible for project deployment. (consists of 23 phases as its the main build lifecycle.)
    clean: to clean the project and remove all files generated by the previous build. (3 phases)
    site: to create the projects site documentation. (4 phases)

So,

Build LifeCycle
	Build Phases
		Build Goals

For example the default lifecycle comprises of the following Build Phases:

	◾validate - validate the project is correct and all necessary information is available
	◾compile - compile the source code of the project
	◾test - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed
	◾package - take the compiled code and package it in its distributable format, such as a JAR.
	◾integration-test - process and deploy the package if necessary into an environment where integration tests can be run
	◾verify - run any checks to verify the package is valid and meets quality criteria
	◾install - install the package into the local repository, for use as a dependency in other projects locally
	◾deploy - done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.

So to go through the above phases, we just have to call one command:

	mvn <phase> { Ex: mvn install }

For the above command, starting from the first phase, all the phases are executed sequentially till the ‘install’ phase. mvn can either execute a goal or a phase (or even multiple goals or multiple phases) as follows:

	mvn clean install plugin:goal  

However, if you want to customize the prefix used to reference your plugin, you can specify the prefix directly through a configuration parameter on the maven-plugin-plugin in your plugin's POM.


Extra:
	mvn compile exec:java -Dexec.mainClass="com.example.src.main.java.MainClass" -Dexec.args="arg1 arg2"
		On Windows we double quote key and value. ie. -D"exec.args"="arg1 arg2"


--------------------------------------------- GOALS

Here are some of the phases and default goals bound to them:

    compiler:compile – the compile goal from the compiler plugin is bound to the compile phase
    compiler:testCompile is bound to the test-compile phase
    surefire:test is bound to test phase
    install:install is bound to install phase
    jar:jar and war:war is bound to package phase

We can list all goals bound to a specific phase and their plugins using the command:

	mvn help:describe -Dcmd=PHASENAME

For example, to list all goals bound to the compile phase, we can run:
	
	mvn help:describe -Dcmd=compile

And get the sample output:
compile is a phase corresponding to this plugin:
org.apache.maven.plugins:maven-compiler-plugin:3.1:compile

We can use the following command to list all goals in a specific plugin:

	mvn <PLUGIN>:help (ie. mvn failsafe:help)

To run a specific goal, without executing its entire phase (and the preceding phases) we can use the command:

	mvn <PLUGIN>:<GOAL> (ie. mvn failsafe:integration-test)

** Building a Maven Project

To build a Maven project, we need to execute one of the life cycles by running one of their phases:
	
	mvn deploy (This will execute the entire default lifecycle).
	mvn install	
	mvn clean install (usually we will use the command, to clean the project first – by running the clean lifecycle – before the new build.
	mvn compiler:compile (We can also run only a specific goal of the plugin)

Note that if we tried to build a Maven project without specifying a phase or a goal, that will cause the error:
	[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal


----------------------------------------

** A Build Phase is Made Up of Plugin Goals

Most of Maven's functionality is in plugins. A plugin provides a set of goals that can be executed using the following syntax:

	mvn [plugin-name]:[goal-name]

For example, a Java project can be compiled with the compiler-plugin's compile-goal by running mvn compiler:compile.

Build lifecycle is a list of named phases that can be used to give order to goal execution.


** Goals provided by plugins can be associated with different phases of the lifecycle.

For example, by default, the goal compiler:compile is associated with the compile phase, while the goal surefire:test is associated with the test phase. Consider the following command:

	mvn test

When the preceding command is executed, Maven runs all goals associated with each of the phases up to and including the test phase. In such a case, Maven runs the resources:resources goal associated with the process-resources phase, then compiler:compile, and so on until it finally runs the surefire:test goal.

However, even though a build phase is responsible for a specific step in the build lifecycle, the manner in which it carries out those responsibilities may vary. And this is done by declaring the plugin goals bound to those build phases.

A plugin goal represents a specific task (finer than a build phase) which contributes to the building and managing of a project. It may be bound to zero or more build phases. A goal not bound to any build phase could be executed outside of the build lifecycle by direct invocation. The order of execution depends on the order in which the goal(s) and the build phase(s) are invoked. For example, consider the command below. The clean and package arguments are build phases, while the dependency:copy-dependencies is a goal (of a plugin).

	mvn clean dependency:copy-dependencies package

If this were to be executed, the clean phase will be executed first (meaning it will run all preceding phases of the clean lifecycle, plus the clean phase itself), and then the dependency:copy-dependencies goal, before finally executing the package phase (and all its preceding build phases of the default lifecycle).

Moreover, if a goal is bound to one or more build phases, that goal will be called in all those phases.

Furthermore, a build phase can also have zero or more goals bound to it. If a build phase has no goals bound to it, that build phase will not execute. But if it has one or more goals bound to it, it will execute all those goals.

** Built-in Lifecycle Bindings
Some phases have goals bound to them by default. And for the default lifecycle, these bindings depend on the packaging value.


---------------------------------------

A Maven plugin is a group of goals. However, these goals aren't necessarily all bound to the same phase.
For example, here's a simple configuration of the Maven Failsafe plugin which is responsible for running integration tests:
<build>
    <plugins>
        <plugin>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>${maven.failsafe.version}</version>
            <executions>
                <execution>
                    <goals>
                        <goal>integration-test</goal>	SE EJECUTARÁ EN ESTAS 2 BUILD PHASES
                        <goal>verify</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>

